<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Suivi de course - TuniDrive</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Arial, sans-serif; background: #0b0b0b; color: #fff; }
    #header { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; background: rgba(0,0,0,0.7); backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 14px; }
    #status { font-size: 13px; opacity: 0.85; }
    #map { position: absolute; top: 52px; bottom: 0; left: 0; right: 0; }
    .pill { padding: 6px 10px; background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 999px; font-size: 12px; color: #cfcfcf; }
    .brand { font-weight: 700; letter-spacing: 0.3px; }
    .badge { padding: 4px 8px; border-radius: 8px; font-size: 12px; border: 1px solid #2a2a2a; background: #111; color: #aaa; }
    a { color: #61dafb; text-decoration: none; }
  </style>
</head>
<body>
  <div id="header">
    <div class="brand">TuniDrive ‚Ä¢ Suivi de course</div>
    <div id="status" class="badge">Initialisation‚Ä¶</div>
  </div>
  <div id="map"></div>

  <script src="./track-config.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    console.log('üöÄ Script de tracking d√©marr√©');
    
    (function() {
      const statusEl = document.getElementById('status');
      console.log('üîç √âl√©ment status trouv√©:', statusEl);

      function setStatus(text) {
        console.log('üìù Changement de statut:', text);
        statusEl.textContent = text;
      }

      function getQueryParam(name) {
        const params = new URLSearchParams(window.location.search);
        return params.get(name);
      }

      async function loadConfig() {
        console.log('üîç Tentative de chargement depuis Netlify Function...');
        // 1) Try to load from Netlify Function at runtime (recommended to avoid exposing keys in repo)
        try {
          const resp = await fetch('/.netlify/functions/public-config', { cache: 'no-store' });
          console.log('üîç R√©ponse Netlify Function:', resp.status, resp.ok);
          if (resp.ok) {
            const json = await resp.json();
            console.log('üîç JSON re√ßu:', json);
            if (json && json.VITE_SUPABASE_URL && json.VITE_SUPABASE_ANON_KEY) {
              console.log('‚úÖ Configuration trouv√©e via Netlify Function');
              return {
                supabaseUrl: json.VITE_SUPABASE_URL,
                supabaseAnonKey: json.VITE_SUPABASE_ANON_KEY,
              };
            }
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è Netlify public-config indisponible, utilisation du fallback:', e);
        }
        
        console.log('üîç Tentative de chargement depuis window.TRACK_CONFIG...');
        console.log('üîç window.TRACK_CONFIG:', window.TRACK_CONFIG);
        
        // 2) Fallback to window.TRACK_CONFIG (static file)
        if (window.TRACK_CONFIG && window.TRACK_CONFIG.supabaseUrl && window.TRACK_CONFIG.supabaseAnonKey) {
          console.log('‚úÖ Configuration trouv√©e via window.TRACK_CONFIG');
          return {
            supabaseUrl: window.TRACK_CONFIG.supabaseUrl,
            supabaseAnonKey: window.TRACK_CONFIG.supabaseAnonKey,
          };
        }
        
        console.log('‚ùå Aucune configuration trouv√©e');
        return null;
      }

      const token = getQueryParam('token');
      if (!token) {
        setStatus('Aucun token de suivi fourni.');
        alert('Param√®tre manquant: ?token=...');
        return;
      }

      (async () => {
        console.log('üîç D√©but du chargement de la configuration...');
        const cfg = await loadConfig();
        console.log('üîç Configuration charg√©e:', cfg);
        
        if (!cfg) {
          setStatus('Configuration Supabase manquante.');
          console.error('Aucune configuration disponible. Configurez la function Netlify \/.netlify\/functions\/public-config ou le fallback public\/track-config.js');
          return;
        }
        
        console.log('‚úÖ Configuration trouv√©e, initialisation de la carte...');

        // Initialiser la carte
        const map = L.map('map', { zoomControl: false });
        const tileUrl = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
        const tileLayer = L.tileLayer(tileUrl, { attribution: '&copy; OpenStreetMap & CARTO' });
        tileLayer.addTo(map);

        // Marqueur du v√©hicule
        const carIcon = L.icon({
          iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          shadowSize: [41, 41]
        });

        let vehicleMarker = null;
        let lastPosition = null;

        function updateMarker(lat, lng, heading) {
          const latLng = [lat, lng];
          if (!vehicleMarker) {
            vehicleMarker = L.marker(latLng, { icon: carIcon });
            vehicleMarker.addTo(map);
            map.setView(latLng, 15);
          } else {
            vehicleMarker.setLatLng(latLng);
          }
          lastPosition = { lat, lng, heading: heading || 0 };
        }

        function fitOnce(lat, lng) {
          if (!map._hasFit) {
            map._hasFit = true;
            map.setView([lat, lng], 15);
          }
        }

        // Supabase Realtime
        console.log('üîç V√©rification de window.supabase...');
        console.log('üîç window.supabase:', window.supabase);
        
        if (!window.supabase) {
          setStatus('Erreur: Supabase non charg√©');
          console.error('window.supabase is undefined. V√©rifiez que le script Supabase est charg√©.');
          return;
        }

        console.log('‚úÖ Supabase trouv√©, cr√©ation du client...');
        const supa = window.supabase.createClient(
          cfg.supabaseUrl,
          cfg.supabaseAnonKey,
          { realtime: { params: { eventsPerSecond: 10 } } }
        );
        console.log('‚úÖ Client Supabase cr√©√©:', supa);

        let channel = null;
        function subscribe() {
          console.log('üîç D√©but de la souscription au canal...');
          setStatus('Connexion au canal‚Ä¶');
          const channelName = `tracking:${token}`;
          console.log('üîç Nom du canal:', channelName);
          channel = supa.channel(channelName, { config: { broadcast: { self: false } } });
          console.log('üîç Canal cr√©√©:', channel);

          channel.on('broadcast', { event: 'position' }, (payload) => {
            const data = payload?.payload || {};
            const { lat, lng, heading, speed, ts } = data;
            if (typeof lat === 'number' && typeof lng === 'number') {
              updateMarker(lat, lng, heading);
              fitOnce(lat, lng);
              const speedKmh = typeof speed === 'number' ? (speed * 3.6).toFixed(0) : '‚Äî';
              const time = ts ? new Date(ts).toLocaleTimeString() : '';
              setStatus(`En direct ‚Ä¢ ${lat.toFixed(5)}, ${lng.toFixed(5)} ‚Ä¢ ${speedKmh} km/h ${time ? '‚Ä¢ ' + time : ''}`);
            }
          });

          channel.subscribe((status) => {
            console.log('üîç Statut de souscription:', status);
            if (status === 'SUBSCRIBED') {
              setStatus('En direct ‚Ä¢ en attente de position‚Ä¶');
              console.log('‚úÖ Canal souscrit avec succ√®s');
            } else if (status === 'CHANNEL_ERROR') {
              setStatus('Erreur de canal. Reconnexion‚Ä¶');
              console.error('‚ùå Erreur de canal');
            } else if (status === 'TIMED_OUT') {
              setStatus('D√©lai d√©pass√©. Reconnexion‚Ä¶');
              console.warn('‚ö†Ô∏è D√©lai d√©pass√©');
            } else if (status === 'CLOSED') {
              setStatus('Canal ferm√©. Tentative de reconnexion‚Ä¶');
              console.warn('‚ö†Ô∏è Canal ferm√©');
            }
          });
        }

        // Gestion reconnexion
        supa.realtime.on('open', () => {
          console.log('‚úÖ Connexion Realtime ouverte');
          setStatus('Connect√© ‚Ä¢ en attente de position‚Ä¶');
        });
        supa.realtime.on('close', () => {
          console.warn('‚ö†Ô∏è Connexion Realtime ferm√©e');
          setStatus('D√©connect√©. Reconnexion‚Ä¶');
        });
        supa.realtime.on('error', (error) => {
          console.error('‚ùå Erreur Realtime:', error);
          setStatus('Erreur r√©seau. Reconnexion‚Ä¶');
        });

        console.log('üîç D√©marrage de la souscription...');
        subscribe();
      })();
    })();
  </script>
</body>
</html>